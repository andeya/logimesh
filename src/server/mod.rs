// Copyright Andeya Lee 2024
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.
//! Server component.

use crate::serde::{Deserialize, Serialize};
use crate::transport::codec::{Codec, CodecFn};
use crate::transport::tcp;
pub use ::tarpc::server::*;
use futures::future;
use futures::prelude::*;
use incoming::Incoming;
use serde::Deserialize;
use tokio::net::ToSocketAddrs;
/// TCP server config.
#[derive(Clone, Debug)]
#[non_exhaustive]
pub struct TcpConfig<A> {
    /// listen address.
    pub(crate) listen_address: A,
    /// transport codec type.
    pub(crate) transport_codec: Codec,
    /// Maximum frame length, default is usize::MAX.
    pub(crate) max_frame_len: usize,
    /// Controls the buffer size of the in-process channel over which a server's handlers send
    /// responses to the [`Channel`]. In other words, this is the number of responses that can sit
    /// in the outbound queue before request handlers begin blocking.
    pub(crate) pending_response_buffer: usize,
    /// Enforces channel per-key limits.
    pub(crate) max_channels_per_key: u32,
    /// An adaptor for creating a buffered list of pending futures (unordered).
    /// Default is 10, and zero means 10.
    pub(crate) buffer_unordered: usize,
}

impl<A> TcpConfig<A> {
    // init config.
    fn init(&mut self) {
        if self.max_frame_len <= 0 {
            self.max_frame_len = usize::MAX;
        }
        if self.buffer_unordered <= 0 {
            self.buffer_unordered = 10;
        }
    }
}

pub async fn tcp_listen<A, S>(config: TcpConfig<A>, serve: S) -> anyhow::Result<()>
where
    A: ToSocketAddrs,
    S: Serve + Clone + 'static,
    S::Req: for<'de> Deserialize<'de> + Unpin + 'static,
    S::Resp: Serialize + Unpin + 'static,
{
    config.init();
    let mut listener = tcp::listen(config.listen_address, config.transport_codec.to_fn()).await?;
    tracing::info!("Listening on port {}", listener.local_addr().port());
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(|transport| {
            BaseChannel::new(
                Config {
                    pending_response_buffer: config.pending_response_buffer,
                },
                transport,
            )
        })
        // Limit channels to 1 per IP.
        .max_channels_per_key(config.max_channels_per_key, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the component attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            channel.execute(serve).for_each(|fut| async {
                tokio::spawn(fut);
            })
        })
        // Max 10 channels.
        .buffer_unordered(config.buffer_unordered)
        .for_each(|_| async {})
        .await;
    Ok(())
}
